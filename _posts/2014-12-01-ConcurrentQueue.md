---
layout: post
title: 阻塞和非阻塞并发队列算法
descriptionii: "我们将描述两个具有实践性的算法，一个非阻塞的并发队列算法，以及另一个具有入队锁和出队锁的阻塞算法。"
modified: 2014-12-01
tags: [algorithms]
---

###简介
&emsp;&emsp;并发FIFO队列在并行程序以及操作系统中有广泛的应用，为了确保程序的正确性，在并发访问共享队列的时候必须进行同步化。举个例子，比如在生产者与消费者模型的应用中，在没有产品时，消费者就必须要等到生产者生产出产品后才能运行。对于像FIFO队列这样的并发数据结构的算法，一般分成两种：阻塞和非阻塞，阻塞算法使用一个延迟的进程去避免更快进程在不确定的共享内存中完成操作，这个延迟同步进程可以看成锁。非阻塞算法保证在一个或多个活跃进程尝试操作共享数据结构的时候，某些操作将在有限的时间周期内完成，不会发生因为像抢锁所形成的死锁情况。在同步多进程系统中，尤其是多进程的情况，阻塞算法中，当一个进程在不适当的时间被挂起或延迟的时候，阻塞算法的性能将会严重下降。延迟可能的原因有进程的抢占式调度，页面中断(引起页面置换)，以及缓存未命中。但是，在面对以上问题，非阻塞算法鲁棒性更好,更健壮。

&emsp;&emsp;许多研究者对于并发FIFO队列使用无锁算法,Hwang和B日Briggs,Stong,Sites均描述了无锁算法基于`compare_and_swap`的实现(把共享内存地址,一个保留值,以及一个
新值当作参数，如果共享内存中目前保存着保留值，那么它将被标记为新值，返回一个布尔值标记是否发生交换，显然这个预留值的设定也是一门学问）。但这个算法不是特别详细，他们
省略了一些详细内容，比如处理单元素队列，空队列以及并发的出队，入队行为。Lamport描述了一个无等待算法（非阻塞和无饥俄性算法，该算法保证每一个活动进程在有限的时间片内得到处理），这个算法使用入队器和出队器限制并发。

&emsp;&emsp;Gottlieb和Mellor-Crummey描述了一个无锁但是不是非阻塞的算法：他们不使用锁的机制，但是他们允许一个慢的进程去延迟不确定的较快进程。

&emsp;&emsp;Treiber描述了一个非阻塞的算法，但是效率低，一个出队操作花费的时间与队列元素个数成正比.Herlihy,Prakash,Lee,Johnson,Turek,Shasha,Prakash,Barnes提议使用
一般的方法，对于非阻塞算法，使用版本序列或者基于锁控制来实现。通常而言，这种的效果相比特殊方法是低效率的。

&emsp;&emsp;Massalin和Pu描述了一种基于`double_compare_and_swap`的无锁算法，该算法可以同时操作两个任意的内存位置，但是似乎只能在Motorola 68000之后的处理器才能使用，
Herlihy和Wing描述了一种基于数组的算法，但是该算法对于数组的需求不确定。Valois描述了一种基于数组的算法，需要一个未对齐的`compare_and_swap`或者`double_compare_and_swap`。

&emsp;&emsp;Stone描述了一个无锁算法，但是它是非线性(如果在数据结构之外给一个外部的观察者，观察对数据结构的操作，在某时刻对它的调用和响应都能观察到立即产生的影响，就说这个数据结构的实现是可线性的)和阻塞的。因其是非线性的，所以当一个慢的入队器观察到一个空的队列，但是某个快的入队操作已经随后加入了一个元素，甚至可能出现这个已经入队元素永远不出队。因为一个慢的入队操作能够通过其他不确定的进程延迟出队操作，所以它也是非阻塞的。我们的实验同时也揭露存在竞争条件，比如一个慢的入队操作，以及一个快的入队操作和一个快的出队操作，将可能造成某个入队元素丢失(快的出队操作已经执行，慢的出队操作又执行了一次，所以造成了某个入队的元素被莫名其妙移除),这就是两个出队操作存在竞争的原因。Stone也描述了一个基于循环单链表的队列，该算法使用锚点指针代替头尾指针管理队列，我们的实验同样揭露存在一个竞争条件：慢的出队操作进程能造成入队元素永久丢失。

&emsp;&emsp;
Prakash,Lee 和Johnson描述了一种线性非阻塞算法，它需要入队进程和出队进程在决定更新队列的状态之前获取它的一个快照，这个算法通过允许快进程去完成慢进程的操作代
替阻塞来达到非阻塞的性能。

-----
未完待续
